// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `data_model.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    Id: ::std::option::Option<i32>,
    Release: ::protobuf::SingularPtrField<TimeStamp>,
    Due: ::protobuf::SingularPtrField<TimeStamp>,
    Ready: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // optional int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id.unwrap_or(0i32)
    }
    pub fn clear_Id(&mut self) {
        self.Id = ::std::option::Option::None;
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = ::std::option::Option::Some(v);
    }

    // optional .DynStacking.DataModel.TimeStamp Release = 2;


    pub fn get_Release(&self) -> &TimeStamp {
        self.Release.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Release(&mut self) {
        self.Release.clear();
    }

    pub fn has_Release(&self) -> bool {
        self.Release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Release(&mut self, v: TimeStamp) {
        self.Release = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Release(&mut self) -> &mut TimeStamp {
        if self.Release.is_none() {
            self.Release.set_default();
        }
        self.Release.as_mut().unwrap()
    }

    // Take field
    pub fn take_Release(&mut self) -> TimeStamp {
        self.Release.take().unwrap_or_else(|| TimeStamp::new())
    }

    // optional .DynStacking.DataModel.TimeStamp Due = 3;


    pub fn get_Due(&self) -> &TimeStamp {
        self.Due.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Due(&mut self) {
        self.Due.clear();
    }

    pub fn has_Due(&self) -> bool {
        self.Due.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Due(&mut self, v: TimeStamp) {
        self.Due = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Due(&mut self) -> &mut TimeStamp {
        if self.Due.is_none() {
            self.Due.set_default();
        }
        self.Due.as_mut().unwrap()
    }

    // Take field
    pub fn take_Due(&mut self) -> TimeStamp {
        self.Due.take().unwrap_or_else(|| TimeStamp::new())
    }

    // optional bool Ready = 4;


    pub fn get_Ready(&self) -> bool {
        self.Ready.unwrap_or(false)
    }
    pub fn clear_Ready(&mut self) {
        self.Ready = ::std::option::Option::None;
    }

    pub fn has_Ready(&self) -> bool {
        self.Ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Ready(&mut self, v: bool) {
        self.Ready = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.Release {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Due {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Release)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Due)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ready = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Release.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Due.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.Ready {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.Release.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Due.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.Ready {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Block| { &m.Id },
                    |m: &mut Block| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Release",
                    |m: &Block| { &m.Release },
                    |m: &mut Block| { &mut m.Release },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Due",
                    |m: &Block| { &m.Due },
                    |m: &mut Block| { &mut m.Due },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ready",
                    |m: &Block| { &m.Ready },
                    |m: &mut Block| { &mut m.Ready },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.Id = ::std::option::Option::None;
        self.Release.clear();
        self.Due.clear();
        self.Ready = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Crane {
    // message fields
    Id: ::std::option::Option<i32>,
    LocationId: ::std::option::Option<i32>,
    Load: ::protobuf::SingularPtrField<Block>,
    Schedule: ::protobuf::SingularPtrField<CraneSchedule>,
    GirderPosition: ::std::option::Option<f64>,
    HoistPosition: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Crane {
    fn default() -> &'a Crane {
        <Crane as ::protobuf::Message>::default_instance()
    }
}

impl Crane {
    pub fn new() -> Crane {
        ::std::default::Default::default()
    }

    // optional int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id.unwrap_or(0i32)
    }
    pub fn clear_Id(&mut self) {
        self.Id = ::std::option::Option::None;
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = ::std::option::Option::Some(v);
    }

    // optional int32 LocationId = 2;


    pub fn get_LocationId(&self) -> i32 {
        self.LocationId.unwrap_or(0i32)
    }
    pub fn clear_LocationId(&mut self) {
        self.LocationId = ::std::option::Option::None;
    }

    pub fn has_LocationId(&self) -> bool {
        self.LocationId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_LocationId(&mut self, v: i32) {
        self.LocationId = ::std::option::Option::Some(v);
    }

    // optional .DynStacking.DataModel.Block Load = 3;


    pub fn get_Load(&self) -> &Block {
        self.Load.as_ref().unwrap_or_else(|| Block::default_instance())
    }
    pub fn clear_Load(&mut self) {
        self.Load.clear();
    }

    pub fn has_Load(&self) -> bool {
        self.Load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Load(&mut self, v: Block) {
        self.Load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Load(&mut self) -> &mut Block {
        if self.Load.is_none() {
            self.Load.set_default();
        }
        self.Load.as_mut().unwrap()
    }

    // Take field
    pub fn take_Load(&mut self) -> Block {
        self.Load.take().unwrap_or_else(|| Block::new())
    }

    // optional .DynStacking.DataModel.CraneSchedule Schedule = 4;


    pub fn get_Schedule(&self) -> &CraneSchedule {
        self.Schedule.as_ref().unwrap_or_else(|| CraneSchedule::default_instance())
    }
    pub fn clear_Schedule(&mut self) {
        self.Schedule.clear();
    }

    pub fn has_Schedule(&self) -> bool {
        self.Schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Schedule(&mut self, v: CraneSchedule) {
        self.Schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Schedule(&mut self) -> &mut CraneSchedule {
        if self.Schedule.is_none() {
            self.Schedule.set_default();
        }
        self.Schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_Schedule(&mut self) -> CraneSchedule {
        self.Schedule.take().unwrap_or_else(|| CraneSchedule::new())
    }

    // optional double GirderPosition = 5;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition.unwrap_or(0.0f64)
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = ::std::option::Option::None;
    }

    pub fn has_GirderPosition(&self) -> bool {
        self.GirderPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = ::std::option::Option::Some(v);
    }

    // optional double HoistPosition = 6;


    pub fn get_HoistPosition(&self) -> f64 {
        self.HoistPosition.unwrap_or(0.0f64)
    }
    pub fn clear_HoistPosition(&mut self) {
        self.HoistPosition = ::std::option::Option::None;
    }

    pub fn has_HoistPosition(&self) -> bool {
        self.HoistPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_HoistPosition(&mut self, v: f64) {
        self.HoistPosition = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Crane {
    fn is_initialized(&self) -> bool {
        for v in &self.Load {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.LocationId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Load)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Schedule)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HoistPosition = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.LocationId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.GirderPosition {
            my_size += 9;
        }
        if let Some(v) = self.HoistPosition {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.LocationId {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.Load.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Schedule.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.GirderPosition {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.HoistPosition {
            os.write_double(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Crane {
        Crane::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Crane| { &m.Id },
                    |m: &mut Crane| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "LocationId",
                    |m: &Crane| { &m.LocationId },
                    |m: &mut Crane| { &mut m.LocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "Load",
                    |m: &Crane| { &m.Load },
                    |m: &mut Crane| { &mut m.Load },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneSchedule>>(
                    "Schedule",
                    |m: &Crane| { &m.Schedule },
                    |m: &mut Crane| { &mut m.Schedule },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Crane| { &m.GirderPosition },
                    |m: &mut Crane| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HoistPosition",
                    |m: &Crane| { &m.HoistPosition },
                    |m: &mut Crane| { &mut m.HoistPosition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Crane>(
                    "Crane",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Crane {
        static mut instance: ::protobuf::lazy::Lazy<Crane> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Crane,
        };
        unsafe {
            instance.get(Crane::new)
        }
    }
}

impl ::protobuf::Clear for Crane {
    fn clear(&mut self) {
        self.Id = ::std::option::Option::None;
        self.LocationId = ::std::option::Option::None;
        self.Load.clear();
        self.Schedule.clear();
        self.GirderPosition = ::std::option::Option::None;
        self.HoistPosition = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Crane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Crane {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneMove {
    // message fields
    BlockId: ::std::option::Option<i32>,
    SourceId: ::std::option::Option<i32>,
    TargetId: ::std::option::Option<i32>,
    Sequence: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneMove {
    fn default() -> &'a CraneMove {
        <CraneMove as ::protobuf::Message>::default_instance()
    }
}

impl CraneMove {
    pub fn new() -> CraneMove {
        ::std::default::Default::default()
    }

    // optional int32 BlockId = 1;


    pub fn get_BlockId(&self) -> i32 {
        self.BlockId.unwrap_or(0)
    }
    pub fn clear_BlockId(&mut self) {
        self.BlockId = ::std::option::Option::None;
    }

    pub fn has_BlockId(&self) -> bool {
        self.BlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BlockId(&mut self, v: i32) {
        self.BlockId = ::std::option::Option::Some(v);
    }

    // optional int32 SourceId = 2;


    pub fn get_SourceId(&self) -> i32 {
        self.SourceId.unwrap_or(0)
    }
    pub fn clear_SourceId(&mut self) {
        self.SourceId = ::std::option::Option::None;
    }

    pub fn has_SourceId(&self) -> bool {
        self.SourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SourceId(&mut self, v: i32) {
        self.SourceId = ::std::option::Option::Some(v);
    }

    // optional int32 TargetId = 3;


    pub fn get_TargetId(&self) -> i32 {
        self.TargetId.unwrap_or(0i32)
    }
    pub fn clear_TargetId(&mut self) {
        self.TargetId = ::std::option::Option::None;
    }

    pub fn has_TargetId(&self) -> bool {
        self.TargetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TargetId(&mut self, v: i32) {
        self.TargetId = ::std::option::Option::Some(v);
    }

    // optional int32 Sequence = 4;


    pub fn get_Sequence(&self) -> i32 {
        self.Sequence.unwrap_or(0i32)
    }
    pub fn clear_Sequence(&mut self) {
        self.Sequence = ::std::option::Option::None;
    }

    pub fn has_Sequence(&self) -> bool {
        self.Sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Sequence(&mut self, v: i32) {
        self.Sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CraneMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.BlockId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.SourceId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TargetId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Sequence = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.BlockId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.SourceId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.TargetId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Sequence {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.BlockId {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.SourceId {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.TargetId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.Sequence {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneMove {
        CraneMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "BlockId",
                    |m: &CraneMove| { &m.BlockId },
                    |m: &mut CraneMove| { &mut m.BlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "SourceId",
                    |m: &CraneMove| { &m.SourceId },
                    |m: &mut CraneMove| { &mut m.SourceId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TargetId",
                    |m: &CraneMove| { &m.TargetId },
                    |m: &mut CraneMove| { &mut m.TargetId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Sequence",
                    |m: &CraneMove| { &m.Sequence },
                    |m: &mut CraneMove| { &mut m.Sequence },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneMove>(
                    "CraneMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneMove {
        static mut instance: ::protobuf::lazy::Lazy<CraneMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneMove,
        };
        unsafe {
            instance.get(CraneMove::new)
        }
    }
}

impl ::protobuf::Clear for CraneMove {
    fn clear(&mut self) {
        self.BlockId = ::std::option::Option::None;
        self.SourceId = ::std::option::Option::None;
        self.TargetId = ::std::option::Option::None;
        self.Sequence = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneSchedule {
    // message fields
    Moves: ::protobuf::RepeatedField<CraneMove>,
    SequenceNr: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneSchedule {
    fn default() -> &'a CraneSchedule {
        <CraneSchedule as ::protobuf::Message>::default_instance()
    }
}

impl CraneSchedule {
    pub fn new() -> CraneSchedule {
        ::std::default::Default::default()
    }

    // repeated .DynStacking.DataModel.CraneMove Moves = 1;


    pub fn get_Moves(&self) -> &[CraneMove] {
        &self.Moves
    }
    pub fn clear_Moves(&mut self) {
        self.Moves.clear();
    }

    // Param is passed by value, moved
    pub fn set_Moves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.Moves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Moves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.Moves
    }

    // Take field
    pub fn take_Moves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.Moves, ::protobuf::RepeatedField::new())
    }

    // optional int32 SequenceNr = 2;


    pub fn get_SequenceNr(&self) -> i32 {
        self.SequenceNr.unwrap_or(0i32)
    }
    pub fn clear_SequenceNr(&mut self) {
        self.SequenceNr = ::std::option::Option::None;
    }

    pub fn has_SequenceNr(&self) -> bool {
        self.SequenceNr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SequenceNr(&mut self, v: i32) {
        self.SequenceNr = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CraneSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.Moves {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Moves)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.SequenceNr = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Moves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.SequenceNr {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Moves {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.SequenceNr {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneSchedule {
        CraneSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "Moves",
                    |m: &CraneSchedule| { &m.Moves },
                    |m: &mut CraneSchedule| { &mut m.Moves },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "SequenceNr",
                    |m: &CraneSchedule| { &m.SequenceNr },
                    |m: &mut CraneSchedule| { &mut m.SequenceNr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneSchedule>(
                    "CraneSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneSchedule {
        static mut instance: ::protobuf::lazy::Lazy<CraneSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneSchedule,
        };
        unsafe {
            instance.get(CraneSchedule::new)
        }
    }
}

impl ::protobuf::Clear for CraneSchedule {
    fn clear(&mut self) {
        self.Moves.clear();
        self.SequenceNr = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Handover {
    // message fields
    Id: ::std::option::Option<i32>,
    Ready: ::std::option::Option<bool>,
    Block: ::protobuf::SingularPtrField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Handover {
    fn default() -> &'a Handover {
        <Handover as ::protobuf::Message>::default_instance()
    }
}

impl Handover {
    pub fn new() -> Handover {
        ::std::default::Default::default()
    }

    // optional int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id.unwrap_or(0i32)
    }
    pub fn clear_Id(&mut self) {
        self.Id = ::std::option::Option::None;
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = ::std::option::Option::Some(v);
    }

    // optional bool Ready = 2;


    pub fn get_Ready(&self) -> bool {
        self.Ready.unwrap_or(false)
    }
    pub fn clear_Ready(&mut self) {
        self.Ready = ::std::option::Option::None;
    }

    pub fn has_Ready(&self) -> bool {
        self.Ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Ready(&mut self, v: bool) {
        self.Ready = ::std::option::Option::Some(v);
    }

    // optional .DynStacking.DataModel.Block Block = 3;


    pub fn get_Block(&self) -> &Block {
        self.Block.as_ref().unwrap_or_else(|| Block::default_instance())
    }
    pub fn clear_Block(&mut self) {
        self.Block.clear();
    }

    pub fn has_Block(&self) -> bool {
        self.Block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Block(&mut self, v: Block) {
        self.Block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Block(&mut self) -> &mut Block {
        if self.Block.is_none() {
            self.Block.set_default();
        }
        self.Block.as_mut().unwrap()
    }

    // Take field
    pub fn take_Block(&mut self) -> Block {
        self.Block.take().unwrap_or_else(|| Block::new())
    }
}

impl ::protobuf::Message for Handover {
    fn is_initialized(&self) -> bool {
        for v in &self.Block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.Ready = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Ready {
            my_size += 2;
        }
        if let Some(ref v) = self.Block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.Ready {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.Block.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Handover {
        Handover::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Handover| { &m.Id },
                    |m: &mut Handover| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "Ready",
                    |m: &Handover| { &m.Ready },
                    |m: &mut Handover| { &mut m.Ready },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "Block",
                    |m: &Handover| { &m.Block },
                    |m: &mut Handover| { &mut m.Block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Handover>(
                    "Handover",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Handover {
        static mut instance: ::protobuf::lazy::Lazy<Handover> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Handover,
        };
        unsafe {
            instance.get(Handover::new)
        }
    }
}

impl ::protobuf::Clear for Handover {
    fn clear(&mut self) {
        self.Id = ::std::option::Option::None;
        self.Ready = ::std::option::Option::None;
        self.Block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Handover {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Handover {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performance {
    // message fields
    CraneManipulations: ::std::option::Option<i32>,
    ServiceLevelMean: ::std::option::Option<f64>,
    LeadTimeMean: ::std::option::Option<f64>,
    DeliveredBlocks: ::std::option::Option<i32>,
    TotalBlocksOnTime: ::std::option::Option<i32>,
    BlockedArrivalTime: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Performance {
    fn default() -> &'a Performance {
        <Performance as ::protobuf::Message>::default_instance()
    }
}

impl Performance {
    pub fn new() -> Performance {
        ::std::default::Default::default()
    }

    // optional int32 CraneManipulations = 1;


    pub fn get_CraneManipulations(&self) -> i32 {
        self.CraneManipulations.unwrap_or(0i32)
    }
    pub fn clear_CraneManipulations(&mut self) {
        self.CraneManipulations = ::std::option::Option::None;
    }

    pub fn has_CraneManipulations(&self) -> bool {
        self.CraneManipulations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CraneManipulations(&mut self, v: i32) {
        self.CraneManipulations = ::std::option::Option::Some(v);
    }

    // optional double ServiceLevelMean = 2;


    pub fn get_ServiceLevelMean(&self) -> f64 {
        self.ServiceLevelMean.unwrap_or(0.0f64)
    }
    pub fn clear_ServiceLevelMean(&mut self) {
        self.ServiceLevelMean = ::std::option::Option::None;
    }

    pub fn has_ServiceLevelMean(&self) -> bool {
        self.ServiceLevelMean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ServiceLevelMean(&mut self, v: f64) {
        self.ServiceLevelMean = ::std::option::Option::Some(v);
    }

    // optional double LeadTimeMean = 3;


    pub fn get_LeadTimeMean(&self) -> f64 {
        self.LeadTimeMean.unwrap_or(0.0f64)
    }
    pub fn clear_LeadTimeMean(&mut self) {
        self.LeadTimeMean = ::std::option::Option::None;
    }

    pub fn has_LeadTimeMean(&self) -> bool {
        self.LeadTimeMean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_LeadTimeMean(&mut self, v: f64) {
        self.LeadTimeMean = ::std::option::Option::Some(v);
    }

    // optional int32 DeliveredBlocks = 4;


    pub fn get_DeliveredBlocks(&self) -> i32 {
        self.DeliveredBlocks.unwrap_or(0i32)
    }
    pub fn clear_DeliveredBlocks(&mut self) {
        self.DeliveredBlocks = ::std::option::Option::None;
    }

    pub fn has_DeliveredBlocks(&self) -> bool {
        self.DeliveredBlocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DeliveredBlocks(&mut self, v: i32) {
        self.DeliveredBlocks = ::std::option::Option::Some(v);
    }

    // optional int32 TotalBlocksOnTime = 5;


    pub fn get_TotalBlocksOnTime(&self) -> i32 {
        self.TotalBlocksOnTime.unwrap_or(0i32)
    }
    pub fn clear_TotalBlocksOnTime(&mut self) {
        self.TotalBlocksOnTime = ::std::option::Option::None;
    }

    pub fn has_TotalBlocksOnTime(&self) -> bool {
        self.TotalBlocksOnTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotalBlocksOnTime(&mut self, v: i32) {
        self.TotalBlocksOnTime = ::std::option::Option::Some(v);
    }

    // optional double BlockedArrivalTime = 6;


    pub fn get_BlockedArrivalTime(&self) -> f64 {
        self.BlockedArrivalTime.unwrap_or(0.0f64)
    }
    pub fn clear_BlockedArrivalTime(&mut self) {
        self.BlockedArrivalTime = ::std::option::Option::None;
    }

    pub fn has_BlockedArrivalTime(&self) -> bool {
        self.BlockedArrivalTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BlockedArrivalTime(&mut self, v: f64) {
        self.BlockedArrivalTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Performance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneManipulations = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ServiceLevelMean = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.LeadTimeMean = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DeliveredBlocks = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TotalBlocksOnTime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.BlockedArrivalTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.CraneManipulations {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ServiceLevelMean {
            my_size += 9;
        }
        if let Some(v) = self.LeadTimeMean {
            my_size += 9;
        }
        if let Some(v) = self.DeliveredBlocks {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.TotalBlocksOnTime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.BlockedArrivalTime {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.CraneManipulations {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ServiceLevelMean {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.LeadTimeMean {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.DeliveredBlocks {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.TotalBlocksOnTime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.BlockedArrivalTime {
            os.write_double(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performance {
        Performance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneManipulations",
                    |m: &Performance| { &m.CraneManipulations },
                    |m: &mut Performance| { &mut m.CraneManipulations },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ServiceLevelMean",
                    |m: &Performance| { &m.ServiceLevelMean },
                    |m: &mut Performance| { &mut m.ServiceLevelMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "LeadTimeMean",
                    |m: &Performance| { &m.LeadTimeMean },
                    |m: &mut Performance| { &mut m.LeadTimeMean },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DeliveredBlocks",
                    |m: &Performance| { &m.DeliveredBlocks },
                    |m: &mut Performance| { &mut m.DeliveredBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TotalBlocksOnTime",
                    |m: &Performance| { &m.TotalBlocksOnTime },
                    |m: &mut Performance| { &mut m.TotalBlocksOnTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "BlockedArrivalTime",
                    |m: &Performance| { &m.BlockedArrivalTime },
                    |m: &mut Performance| { &mut m.BlockedArrivalTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performance>(
                    "Performance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performance {
        static mut instance: ::protobuf::lazy::Lazy<Performance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performance,
        };
        unsafe {
            instance.get(Performance::new)
        }
    }
}

impl ::protobuf::Clear for Performance {
    fn clear(&mut self) {
        self.CraneManipulations = ::std::option::Option::None;
        self.ServiceLevelMean = ::std::option::Option::None;
        self.LeadTimeMean = ::std::option::Option::None;
        self.DeliveredBlocks = ::std::option::Option::None;
        self.TotalBlocksOnTime = ::std::option::Option::None;
        self.BlockedArrivalTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stack {
    // message fields
    Id: ::std::option::Option<i32>,
    MaxHeight: ::std::option::Option<i32>,
    BottomToTop: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stack {
    fn default() -> &'a Stack {
        <Stack as ::protobuf::Message>::default_instance()
    }
}

impl Stack {
    pub fn new() -> Stack {
        ::std::default::Default::default()
    }

    // optional int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id.unwrap_or(0i32)
    }
    pub fn clear_Id(&mut self) {
        self.Id = ::std::option::Option::None;
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = ::std::option::Option::Some(v);
    }

    // optional int32 MaxHeight = 2;


    pub fn get_MaxHeight(&self) -> i32 {
        self.MaxHeight.unwrap_or(0i32)
    }
    pub fn clear_MaxHeight(&mut self) {
        self.MaxHeight = ::std::option::Option::None;
    }

    pub fn has_MaxHeight(&self) -> bool {
        self.MaxHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MaxHeight(&mut self, v: i32) {
        self.MaxHeight = ::std::option::Option::Some(v);
    }

    // repeated .DynStacking.DataModel.Block BottomToTop = 3;


    pub fn get_BottomToTop(&self) -> &[Block] {
        &self.BottomToTop
    }
    pub fn clear_BottomToTop(&mut self) {
        self.BottomToTop.clear();
    }

    // Param is passed by value, moved
    pub fn set_BottomToTop(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.BottomToTop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BottomToTop(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.BottomToTop
    }

    // Take field
    pub fn take_BottomToTop(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.BottomToTop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Stack {
    fn is_initialized(&self) -> bool {
        for v in &self.BottomToTop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MaxHeight = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.BottomToTop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.MaxHeight {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.BottomToTop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.MaxHeight {
            os.write_int32(2, v)?;
        }
        for v in &self.BottomToTop {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stack {
        Stack::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Stack| { &m.Id },
                    |m: &mut Stack| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MaxHeight",
                    |m: &Stack| { &m.MaxHeight },
                    |m: &mut Stack| { &mut m.MaxHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "BottomToTop",
                    |m: &Stack| { &m.BottomToTop },
                    |m: &mut Stack| { &mut m.BottomToTop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stack>(
                    "Stack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stack {
        static mut instance: ::protobuf::lazy::Lazy<Stack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stack,
        };
        unsafe {
            instance.get(Stack::new)
        }
    }
}

impl ::protobuf::Clear for Stack {
    fn clear(&mut self) {
        self.Id = ::std::option::Option::None;
        self.MaxHeight = ::std::option::Option::None;
        self.BottomToTop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamp {
    // message fields
    MilliSeconds: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeStamp {
    fn default() -> &'a TimeStamp {
        <TimeStamp as ::protobuf::Message>::default_instance()
    }
}

impl TimeStamp {
    pub fn new() -> TimeStamp {
        ::std::default::Default::default()
    }

    // optional int64 MilliSeconds = 1;


    pub fn get_MilliSeconds(&self) -> i64 {
        self.MilliSeconds.unwrap_or(0i64)
    }
    pub fn clear_MilliSeconds(&mut self) {
        self.MilliSeconds = ::std::option::Option::None;
    }

    pub fn has_MilliSeconds(&self) -> bool {
        self.MilliSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MilliSeconds(&mut self, v: i64) {
        self.MilliSeconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TimeStamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.MilliSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.MilliSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.MilliSeconds {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamp {
        TimeStamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "MilliSeconds",
                    |m: &TimeStamp| { &m.MilliSeconds },
                    |m: &mut TimeStamp| { &mut m.MilliSeconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamp>(
                    "TimeStamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamp {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamp,
        };
        unsafe {
            instance.get(TimeStamp::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamp {
    fn clear(&mut self) {
        self.MilliSeconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct World {
    // message fields
    Now: ::protobuf::SingularPtrField<TimeStamp>,
    Production: ::protobuf::SingularPtrField<Stack>,
    Buffers: ::protobuf::RepeatedField<Stack>,
    Handover: ::protobuf::SingularPtrField<Handover>,
    Crane: ::protobuf::SingularPtrField<Crane>,
    KPIs: ::protobuf::SingularPtrField<Performance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a World {
    fn default() -> &'a World {
        <World as ::protobuf::Message>::default_instance()
    }
}

impl World {
    pub fn new() -> World {
        ::std::default::Default::default()
    }

    // optional .DynStacking.DataModel.TimeStamp Now = 1;


    pub fn get_Now(&self) -> &TimeStamp {
        self.Now.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Now(&mut self) {
        self.Now.clear();
    }

    pub fn has_Now(&self) -> bool {
        self.Now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Now(&mut self, v: TimeStamp) {
        self.Now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Now(&mut self) -> &mut TimeStamp {
        if self.Now.is_none() {
            self.Now.set_default();
        }
        self.Now.as_mut().unwrap()
    }

    // Take field
    pub fn take_Now(&mut self) -> TimeStamp {
        self.Now.take().unwrap_or_else(|| TimeStamp::new())
    }

    // optional .DynStacking.DataModel.Stack Production = 2;


    pub fn get_Production(&self) -> &Stack {
        self.Production.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Production(&mut self) {
        self.Production.clear();
    }

    pub fn has_Production(&self) -> bool {
        self.Production.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Production(&mut self, v: Stack) {
        self.Production = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Production(&mut self) -> &mut Stack {
        if self.Production.is_none() {
            self.Production.set_default();
        }
        self.Production.as_mut().unwrap()
    }

    // Take field
    pub fn take_Production(&mut self) -> Stack {
        self.Production.take().unwrap_or_else(|| Stack::new())
    }

    // repeated .DynStacking.DataModel.Stack Buffers = 3;


    pub fn get_Buffers(&self) -> &[Stack] {
        &self.Buffers
    }
    pub fn clear_Buffers(&mut self) {
        self.Buffers.clear();
    }

    // Param is passed by value, moved
    pub fn set_Buffers(&mut self, v: ::protobuf::RepeatedField<Stack>) {
        self.Buffers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Buffers(&mut self) -> &mut ::protobuf::RepeatedField<Stack> {
        &mut self.Buffers
    }

    // Take field
    pub fn take_Buffers(&mut self) -> ::protobuf::RepeatedField<Stack> {
        ::std::mem::replace(&mut self.Buffers, ::protobuf::RepeatedField::new())
    }

    // optional .DynStacking.DataModel.Handover Handover = 4;


    pub fn get_Handover(&self) -> &Handover {
        self.Handover.as_ref().unwrap_or_else(|| Handover::default_instance())
    }
    pub fn clear_Handover(&mut self) {
        self.Handover.clear();
    }

    pub fn has_Handover(&self) -> bool {
        self.Handover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Handover(&mut self, v: Handover) {
        self.Handover = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Handover(&mut self) -> &mut Handover {
        if self.Handover.is_none() {
            self.Handover.set_default();
        }
        self.Handover.as_mut().unwrap()
    }

    // Take field
    pub fn take_Handover(&mut self) -> Handover {
        self.Handover.take().unwrap_or_else(|| Handover::new())
    }

    // optional .DynStacking.DataModel.Crane Crane = 5;


    pub fn get_Crane(&self) -> &Crane {
        self.Crane.as_ref().unwrap_or_else(|| Crane::default_instance())
    }
    pub fn clear_Crane(&mut self) {
        self.Crane.clear();
    }

    pub fn has_Crane(&self) -> bool {
        self.Crane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Crane(&mut self, v: Crane) {
        self.Crane = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Crane(&mut self) -> &mut Crane {
        if self.Crane.is_none() {
            self.Crane.set_default();
        }
        self.Crane.as_mut().unwrap()
    }

    // Take field
    pub fn take_Crane(&mut self) -> Crane {
        self.Crane.take().unwrap_or_else(|| Crane::new())
    }

    // optional .DynStacking.DataModel.Performance KPIs = 6;


    pub fn get_KPIs(&self) -> &Performance {
        self.KPIs.as_ref().unwrap_or_else(|| Performance::default_instance())
    }
    pub fn clear_KPIs(&mut self) {
        self.KPIs.clear();
    }

    pub fn has_KPIs(&self) -> bool {
        self.KPIs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_KPIs(&mut self, v: Performance) {
        self.KPIs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_KPIs(&mut self) -> &mut Performance {
        if self.KPIs.is_none() {
            self.KPIs.set_default();
        }
        self.KPIs.as_mut().unwrap()
    }

    // Take field
    pub fn take_KPIs(&mut self) -> Performance {
        self.KPIs.take().unwrap_or_else(|| Performance::new())
    }
}

impl ::protobuf::Message for World {
    fn is_initialized(&self) -> bool {
        for v in &self.Now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Production {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Buffers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Handover {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Crane {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.KPIs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Now)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Production)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Buffers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Handover)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Crane)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.KPIs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Production.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Handover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Crane.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Now.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Production.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.Buffers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Handover.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Crane.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> World {
        World::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Now",
                    |m: &World| { &m.Now },
                    |m: &mut World| { &mut m.Now },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Production",
                    |m: &World| { &m.Production },
                    |m: &mut World| { &mut m.Production },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Buffers",
                    |m: &World| { &m.Buffers },
                    |m: &mut World| { &mut m.Buffers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handover>>(
                    "Handover",
                    |m: &World| { &m.Handover },
                    |m: &mut World| { &mut m.Handover },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Crane>>(
                    "Crane",
                    |m: &World| { &m.Crane },
                    |m: &mut World| { &mut m.Crane },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Performance>>(
                    "KPIs",
                    |m: &World| { &m.KPIs },
                    |m: &mut World| { &mut m.KPIs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<World>(
                    "World",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static World {
        static mut instance: ::protobuf::lazy::Lazy<World> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const World,
        };
        unsafe {
            instance.get(World::new)
        }
    }
}

impl ::protobuf::Clear for World {
    fn clear(&mut self) {
        self.Now.clear();
        self.Production.clear();
        self.Buffers.clear();
        self.Handover.clear();
        self.Crane.clear();
        self.KPIs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for World {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for World {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10data_model.proto\x12\x15DynStacking.DataModel\"\xa7\x01\n\x05Block\
    \x12\x11\n\x02Id\x18\x01\x20\x01(\x05:\x010R\x02Id\x12:\n\x07Release\x18\
    \x02\x20\x01(\x0b2\x20.DynStacking.DataModel.TimeStampR\x07Release\x122\
    \n\x03Due\x18\x03\x20\x01(\x0b2\x20.DynStacking.DataModel.TimeStampR\x03\
    Due\x12\x1b\n\x05Ready\x18\x04\x20\x01(\x08:\x05falseR\x05Ready\"\x85\
    \x02\n\x05Crane\x12\x11\n\x02Id\x18\x01\x20\x01(\x05:\x010R\x02Id\x12!\n\
    \nLocationId\x18\x02\x20\x01(\x05:\x010R\nLocationId\x120\n\x04Load\x18\
    \x03\x20\x01(\x0b2\x1c.DynStacking.DataModel.BlockR\x04Load\x12@\n\x08Sc\
    hedule\x18\x04\x20\x01(\x0b2$.DynStacking.DataModel.CraneScheduleR\x08Sc\
    hedule\x12)\n\x0eGirderPosition\x18\x05\x20\x01(\x01:\x010R\x0eGirderPos\
    ition\x12'\n\rHoistPosition\x18\x06\x20\x01(\x01:\x010R\rHoistPosition\"\
    \x7f\n\tCraneMove\x12\x18\n\x07BlockId\x18\x01\x20\x01(\x05R\x07BlockId\
    \x12\x1a\n\x08SourceId\x18\x02\x20\x01(\x05R\x08SourceId\x12\x1d\n\x08Ta\
    rgetId\x18\x03\x20\x01(\x05:\x010R\x08TargetId\x12\x1d\n\x08Sequence\x18\
    \x04\x20\x01(\x05:\x010R\x08Sequence\"j\n\rCraneSchedule\x126\n\x05Moves\
    \x18\x01\x20\x03(\x0b2\x20.DynStacking.DataModel.CraneMoveR\x05Moves\x12\
    !\n\nSequenceNr\x18\x02\x20\x01(\x05:\x010R\nSequenceNr\"n\n\x08Handover\
    \x12\x11\n\x02Id\x18\x01\x20\x01(\x05:\x010R\x02Id\x12\x1b\n\x05Ready\
    \x18\x02\x20\x01(\x08:\x05falseR\x05Ready\x122\n\x05Block\x18\x03\x20\
    \x01(\x0b2\x1c.DynStacking.DataModel.BlockR\x05Block\"\xa7\x02\n\x0bPerf\
    ormance\x121\n\x12CraneManipulations\x18\x01\x20\x01(\x05:\x010R\x12Cran\
    eManipulations\x12-\n\x10ServiceLevelMean\x18\x02\x20\x01(\x01:\x010R\
    \x10ServiceLevelMean\x12%\n\x0cLeadTimeMean\x18\x03\x20\x01(\x01:\x010R\
    \x0cLeadTimeMean\x12+\n\x0fDeliveredBlocks\x18\x04\x20\x01(\x05:\x010R\
    \x0fDeliveredBlocks\x12/\n\x11TotalBlocksOnTime\x18\x05\x20\x01(\x05:\
    \x010R\x11TotalBlocksOnTime\x121\n\x12BlockedArrivalTime\x18\x06\x20\x01\
    (\x01:\x010R\x12BlockedArrivalTime\"{\n\x05Stack\x12\x11\n\x02Id\x18\x01\
    \x20\x01(\x05:\x010R\x02Id\x12\x1f\n\tMaxHeight\x18\x02\x20\x01(\x05:\
    \x010R\tMaxHeight\x12>\n\x0bBottomToTop\x18\x03\x20\x03(\x0b2\x1c.DynSta\
    cking.DataModel.BlockR\x0bBottomToTop\"2\n\tTimeStamp\x12%\n\x0cMilliSec\
    onds\x18\x01\x20\x01(\x03:\x010R\x0cMilliSeconds\"\xda\x02\n\x05World\
    \x122\n\x03Now\x18\x01\x20\x01(\x0b2\x20.DynStacking.DataModel.TimeStamp\
    R\x03Now\x12<\n\nProduction\x18\x02\x20\x01(\x0b2\x1c.DynStacking.DataMo\
    del.StackR\nProduction\x126\n\x07Buffers\x18\x03\x20\x03(\x0b2\x1c.DynSt\
    acking.DataModel.StackR\x07Buffers\x12;\n\x08Handover\x18\x04\x20\x01(\
    \x0b2\x1f.DynStacking.DataModel.HandoverR\x08Handover\x122\n\x05Crane\
    \x18\x05\x20\x01(\x0b2\x1c.DynStacking.DataModel.CraneR\x05Crane\x126\n\
    \x04KPIs\x18\x06\x20\x01(\x0b2\".DynStacking.DataModel.PerformanceR\x04K\
    PIs\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
